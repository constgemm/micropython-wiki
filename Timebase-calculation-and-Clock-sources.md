###Clock sources
Timers get their clock source from External pins or Internal timer sources.

####External
External = pins: TI1 or TI2 or ETR

1. set pin to be used:
 * in TIMx_CCMR1 reg - set pin to be used by writing CCxS bits
2. select polarity of input
 * in TIMx_CCER reg - write CCxP and CCxNP to select rising, falling or both edges
3. select external clock mode1
 * in TIMx_SMCR reg - write SMS=111
4. optionally configure filter and prescaler
 * in TIMx_CCMR1 - write ICxF[3:0] bits
5. optionally set trigger input source as Timer TIx
 * in TIMx_SMCR reg - write TS bits
6. Enable channel
 * in TIMx_CCER reg - set CCEx bit

If ETR is to be input clock:

1. set clock mode2
 * in TIMx_SMCR reg - set ECE=1
2. configure prescaler, filter, polarity
 * in TIMx_SMCR reg - set ETPS[1:0], ETF[3:0], ETP

####Internal
One Timer can be used as the prescaler for another.

The first timer update_event, or output_compare signal is used as clock for the second.
Uses TRGI to map. Counter mode is set using the TIMx_CR1 reg and CMS bits as indicated in the example below. The counter mode sets whether the update_event occurs on overflow and/or underflow of the Timer.

##Time Base generation
A Timer can be used as a Time base generator. A 16bit timer can generate update_events from nanoseconds up to a few minutes.

The calculation is:
* ```update_event = TIM_CLK / (( PSC + 1) * (APR + 1) * (RCR + 1))```

where:
* TIM_CLK is the timer clock input
* PSC is the 16bit prescaler reg
* ARR is the 16/32bit autoreload reg
* RCR is the 16bit repetition counter

####Examples:
Basic single update_event
* where TIM_CLK=72MHz, Prescaler=1, Autoreload =65535, and no repetition
* update_event = 72 * 10e6 /  ((1+1) (65535+1) (1)) = 549.3 Hz

####External clock mode 1
TIM_CLK is replaced by T1x_CLK - an ext freq applied to pins TI1 or 2
* where TIx_CLK = 50 kHz, Prescaler=1, Autoreload =255, Repetition =2
* update-event = 50000 / ((1+1) (255+1) (2+1)) = 32.55 Hz

####External clock mode 2
TIM_CLK is replaced by ETR_CLK. ETR_PSC is also factored in as follows:
* ```update_event = ETR_CLK / ((ETR_PSC + 1) * ( PSC + 1) * (APR + 1) * (RCR + 1))```
* where ETR_CLK =100kHz, Prescaler=1, ETR_PSC=2, Autoreload=255, and Repetition=2
* update_event = 100 * 10e3 / ((2+1) (1+1) (255+1) (2+1)) = 21.7 Hz

####Internal trigger clock mode 1 (ITRx)
TIM_CLK is replaced by ITRx_CLK which is the internal trigger freq mapped to timer Trigger input TRGI.
* where ITRx_CLK = 8kHz, Prescaler=1, Autoreload=255, Repetition =1
* update_event = 8000 / ((1+1) (255+1) (1+1)) = 7.8Hz

The counter mode indicates if the update_event is generated:
* on overflow - if mode = up counting, the DIR bit is reset in TIMx_CR1
* on underlfow - if mode = down counting, the DIR bit is set in TIMx_CR1
* both - if mode is center aligned, the CMS bits are non zero

The update_event is also generated by:
* software if the UG bit (Update Generation) is set in TIM_EGR reg.
* update generation through the slave mode controller

refer to Timer app note: DM00042534.pdf

